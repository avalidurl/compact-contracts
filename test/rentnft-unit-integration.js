/**
 *
 * autogenerated by solidity-visual-auditor
 *
 * execute with:
 *  #> truffle test test/rentnft.js
 *
 * or:
 *  #> truffle test
 *
 * for all tests
 * */
const RentNft = artifacts.require("RentNft.sol");
const GanFaceNft = artifacts.require("GanFaceNft.sol");
const NILADDR = "0x0000000000000000000000000000000000000000";

contract("RentNft", (accounts) => {
  var creatorAddress = accounts[0];
  var firstOwnerAddress = accounts[1];
  var secondOwnerAddress = accounts[2];
  var externalAddress = accounts[3];
  var unprivilegedAddress = accounts[4];
  /* create named accounts for contract roles */

  before(async () => {
    /* before tests */
  });

  beforeEach(async () => {
    /* before each context */
  });

  it("lends one", async () => {
    const ganFace = await GanFaceNft.deployed();
    const nftAddress = ganFace.address;
    const rent = await RentNft.deployed();

    const fakeTokenURI = "https://fake.ipfs.image.link";
    await ganFace.awardGanFace(creatorAddress, fakeTokenURI);

    const tokenId = "1";
    const maxDuration = "5"; // means 5 days
    const borrowPrice = "1"; // daily DAI borrow price. i.e. 1 DAI per day
    const nftPrice = "100"; // this is the collateral
    const newNftOwner = rent.address; // is our contract
    await ganFace.approve.sendTransaction(newNftOwner, tokenId, { from: creatorAddress });
    await rent.lendOne(nftAddress, tokenId, maxDuration, borrowPrice, nftPrice);
    assert.strictEqual(await ganFace.ownerOf(tokenId), newNftOwner, "rent nft contract is not the new owner");
  });

  it("lends multiple", async () => {
    const ganFace = await GanFaceNft.deployed();
    const nftAddress = ganFace.address;
    const rent = await RentNft.deployed();

    const fakeTokenURI = "https://fake.ipfs.image.link";
    await ganFace.awardGanFace(firstOwnerAddress, fakeTokenURI);
    await ganFace.awardGanFace(firstOwnerAddress, `${fakeTokenURI}.new.face`)

    const newNftOwner = rent.address; // is our contract
    // approves the rent nft contract to handle all of the token ids
    await ganFace.setApprovalForAll.sendTransaction(newNftOwner, true, { from: firstOwnerAddress });
    // await ganFace.approve(newNftOwner, "2", { from: firstOwnerAddress });
    // await ganFace.approve(newNftOwner, "3", { from: firstOwnerAddress });

    // let owner = await ganFace.ownerOf("2");
    // assert.strictEqual(owner, firstOwnerAddress, "incorrect owner");
    // owner = await ganFace.ownerOf("3");
    // assert.strictEqual(owner, firstOwnerAddress, "incorrect owner");

    // await rent.lendOne(nftAddress, "2", "1", "10", "20", { from: firstOwnerAddress });
    // await rent.lendOne(nftAddress, "3", "1", "10", "20", { from: firstOwnerAddress });
    await rent.lendMultiple(
      [nftAddress, nftAddress],
      ["2", "3"], // tokenIds
      ["5", "10"], // maxDuration
      ["1", "2"], // daily borrow price
      ["10", "11"], // collateral
      { from: firstOwnerAddress }
    );

    const nft2 = await rent.nfts(ganFace.address, "2");
    const nft3 = await rent.nfts(ganFace.address, "3");

    assert.strictEqual(nft2.lender, firstOwnerAddress);
    assert.strictEqual(nft2.borrower, NILADDR);
    assert.strictEqual(nft2.maxDuration.toString(), "5");
    assert.strictEqual(nft2.actualDuration.toString(), "0");
    assert.strictEqual(nft2.borrowPrice.toString(), "1");
    assert.strictEqual(nft2.nftPrice.toString(), "10");

    assert.strictEqual(nft3.lender, firstOwnerAddress);
    assert.strictEqual(nft3.borrower, NILADDR);
    assert.strictEqual(nft3.maxDuration.toString(), "10");
    assert.strictEqual(nft3.actualDuration.toString(), "0");
    assert.strictEqual(nft3.borrowPrice.toString(), "2");
    assert.strictEqual(nft3.nftPrice.toString(), "11");
    // assert.strictEqual(await ganFace.ownerOf("1"), newNftOwner, "rent nft contract is not the new owner");
    // assert.strictEqual(await ganFace.ownerOf("2"), newNftOwner, "rent nft contract is not the new owner");
  });
  // it("should revert if ...", () => {
  //   return RentNft.deployed()
  //     .then((instance) => {
  //       return instance.publicOrExternalContractMethod(argument1, argument2, {
  //         from: externalAddress
  //       });
  //     })
  //     .then((result) => {
  //       assert.fail();
  //     })
  //     .catch((error) => {
  //       assert.notEqual(error.message, "assert.fail()", "Reason ...");
  //     });
  // });

  // context("testgroup - security tests - description...", () => {
  //   //deploy a new contract
  //   before(async () => {
  //     /* before tests */
  //     const newRentNft = await RentNft.new("5");
  //   });

  //   beforeEach(async () => {
  //     /* before each tests */
  //   });

  //   it("fails on initialize ...", async () => {
  //     return assertRevert(async () => {
  //       await newRentNft.initialize();
  //     });
  //   });

  //   it("checks if method returns true", async () => {
  //     assert.isTrue(await newRentNft.thisMethodShouldReturnTrue());
  //   });
  // });
});
