/**
 *
 * autogenerated by solidity-visual-auditor
 *
 * execute with:
 *  #> truffle test test/rentnft.js
 *
 * or:
 *  #> truffle test
 *
 * for all tests
 * */
const RentNft = artifacts.require("RentNft.sol");
const GanFaceNft = artifacts.require("GanFaceNft.sol");
const NILADDR = "0x0000000000000000000000000000000000000000";
let rent;
let face;

contract("RentNft", (accounts) => {
  var creatorAddress = accounts[0];
  var firstOwnerAddress = accounts[1];
  // var secondOwnerAddress = accounts[2];
  // var externalAddress = accounts[3];
  // var unprivilegedAddress = accounts[4];
  /* create named accounts for contract roles */

  before(async () => {
    rent = await RentNft.deployed();
    face = await GanFaceNft.deployed();
  });

  beforeEach(async () => {
    /* before each context */
  });

  it("lends one", async () => {
    const fakeTokenURI = "https://fake.ipfs.image.link";
    await face.awardGanFace(creatorAddress, fakeTokenURI);

    const tokenId = "1";
    const maxDuration = "5"; // means 5 days
    const borrowPrice = "1"; // daily DAI borrow price. i.e. 1 DAI per day
    const nftPrice = "100"; // this is the collateral
    await face.approve(rent.address, tokenId, { from: creatorAddress });
    await rent.lendOne(face.address, tokenId, maxDuration, borrowPrice, nftPrice);
    assert.strictEqual(await face.ownerOf(tokenId), rent.address, "rent nft contract is not the new owner");
  });

  it("lends multiple", async () => {
    const fakeTokenURI = "https://fake.ipfs.image.link";
    await face.awardGanFace(firstOwnerAddress, fakeTokenURI);
    await face.awardGanFace(firstOwnerAddress, `${fakeTokenURI}.new.face`)

    await face.setApprovalForAll(rent.address, true, { from: firstOwnerAddress });

    await rent.lendMultiple(
      [face.address, face.address],
      ["2", "3"], // tokenIds
      ["5", "10"], // maxDuration
      ["1", "2"], // daily borrow price
      ["10", "11"], // collateral
      { from: firstOwnerAddress }
    );

    const nft2 = await rent.nfts(face.address, "2");
    const nft3 = await rent.nfts(face.address, "3");

    assert.strictEqual(nft2.lender, firstOwnerAddress);
    assert.strictEqual(nft2.borrower, NILADDR);
    assert.strictEqual(nft2.maxDuration.toString(), "5");
    assert.strictEqual(nft2.actualDuration.toString(), "0");
    assert.strictEqual(nft2.borrowPrice.toString(), "1");
    assert.strictEqual(nft2.nftPrice.toString(), "10");

    assert.strictEqual(nft3.lender, firstOwnerAddress);
    assert.strictEqual(nft3.borrower, NILADDR);
    assert.strictEqual(nft3.maxDuration.toString(), "10");
    assert.strictEqual(nft3.actualDuration.toString(), "0");
    assert.strictEqual(nft3.borrowPrice.toString(), "2");
    assert.strictEqual(nft3.nftPrice.toString(), "11");
    // assert.strictEqual(await ganFace.ownerOf("1"), newNftOwner, "rent nft contract is not the new owner");
    // assert.strictEqual(await ganFace.ownerOf("2"), newNftOwner, "rent nft contract is not the new owner");
  });

  it("rents one", async () => {

  });
  // it("should revert if ...", () => {
  //   return RentNft.deployed()
  //     .then((instance) => {
  //       return instance.publicOrExternalContractMethod(argument1, argument2, {
  //         from: externalAddress
  //       });
  //     })
  //     .then((result) => {
  //       assert.fail();
  //     })
  //     .catch((error) => {
  //       assert.notEqual(error.message, "assert.fail()", "Reason ...");
  //     });
  // });

  // context("testgroup - security tests - description...", () => {
  //   //deploy a new contract
  //   before(async () => {
  //     /* before tests */
  //     const newRentNft = await RentNft.new("5");
  //   });

  //   beforeEach(async () => {
  //     /* before each tests */
  //   });

  //   it("fails on initialize ...", async () => {
  //     return assertRevert(async () => {
  //       await newRentNft.initialize();
  //     });
  //   });

  //   it("checks if method returns true", async () => {
  //     assert.isTrue(await newRentNft.thisMethodShouldReturnTrue());
  //   });
  // });
});
