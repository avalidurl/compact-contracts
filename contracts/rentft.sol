// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import "@chainlink/contracts/src/v0.6/ChainlinkClient.sol";
import "./utils/SafeMath.sol";
import "./utils/ProxyFactory.sol";
import "./utils/OwnableUpgradeSafe.sol";
import "./utils/ContextUpgradeSafe.sol";
import "./utils/Initializable.sol";
import "./utils/Helper.sol";

interface AToken {
  /**
   * @dev redirects the interest generated to a target address.
   * when the interest is redirected, the user's balance is added to
   * the recepient's redirected balance.
   * @param _to the address to which the interest will be redirected
   **/
  function redirectInterestStream(address _to) external;

  /**
   * @dev calculates the balance of the user, which is the
   * principal balance + interest generated by the principal balance +
   * interest generated by the redirected balance
   * @param _user the user for which the balance is being calculated
   * @return the total balance of the user
   **/
  function balanceOf(address _user) external view returns (uint256);
}

// Aave Lending Pool Interface
interface LendingPool {
  function deposit(
    address _reserve,
    uint256 _amount,
    uint16 _referralCode
  ) external;
}

contract InterestCalculatorProxy is Helper, Initializable, OwnableUpgradeSafe {
  event Initialized(address indexed thisAddress);

  // proxy admin would be the owner to prevent in fraud cases where the borrower
  // doesn't return the nft back
  function initialize(address _owner) public initializer {
    OwnableUpgradeSafe.__Ownable_init();
    OwnableUpgradeSafe.transferOwnership(_owner);
    emit Initialized(address(this));
  }

  function claimInterest() external view returns (uint256) {
    // All calculations to be done in the parent contract
    return AToken(getADAI()).balanceOf(address(this));
  }
}

contract Rentft is ProxyFactory, ChainlinkClient, InterestCalculatorProxy {
  using SafeMath for uint256;

  struct Asset {
    address owner;
    address borrower;
    uint256 duration;
    uint256 nftPrice;
    uint256 collateral;
  }

  // proxy details
  // owner => borrower => proxy
  mapping(address => mapping(address => address)) public proxyInfo;

  // nft address => token id => asset info struct
  mapping(address => mapping(uint256 => Asset)) public assets;

  uint256 ourInterestProxy;
  uint256 nftPrice;
  address private oracle;
  bytes32 private jobId;
  uint256 private chainlinkFee;
  // this fee is added on top of the collateral for each hold day of the NFT.
  // This is used to cancel out any potential swings in the price of the NFT
  // denoted in bps (basis points). 1% is 100 bps. 0.1% is 10 bps and
  // equivalently 0.01% is 1 bps.
  uint256 public collateralDailyFee = 100;

  AToken public aETH = AToken(
    address(0xD483B49F2d55D2c53D32bE6efF735cB001880F79)
  );
  // last balances to compute the diff to deposit
  uint256 public lastETHBalance = 0;
  uint256 public lastaETHBalance = 0;

  /**
   * Network: Kovan
   * Oracle: Chainlink - 0x2f90A6D021db21e1B2A077c5a37B3C7E75D15b7e
   * Job ID: Chainlink - 29fa9aa13bf1468788b7cc4a500a45b8
   * Link: 0xa36085F69e2889c224210F603D836748e7dC0088
   * Fee: 0.1 LINK
   */
  constructor() public {
    setPublicChainlinkToken();
    oracle = 0x2f90A6D021db21e1B2A077c5a37B3C7E75D15b7e;
    jobId = "29fa9aa13bf1468788b7cc4a500a45b8";
    chainlinkFee = 0.1 * 10**18; // 0.1 LINK
  }

  // function to list the nft on the platform
  // url will be the nft address
  function addProduct(
    address nftAddress,
    uint256 nftId,
    uint256 duration,
    string calldata _url
  ) external {
    require(nftAddress != address(0), "Invalid NFT Address");
    Chainlink.Request memory request = buildChainlinkRequest(
      jobId,
      address(this),
      this.fulfill.selector
    );

    // Set the URL to perform the GET request on
    request.add("get", _url);

    // Set the path to find the desired data in the API response, where the response format is:
    request.add("path", "last_sale.payment_token.usd_price");

    // Multiply the result by 100 to remove decimals
    request.addInt("times", 1000000000000000000);

    // Sends the request
    sendChainlinkRequestTo(oracle, request, chainlinkFee);

    // need to verify whether the nftPrice will have the latest value
    assets[nftAddress][nftId] = Asset(
      msg.sender,
      address(0),
      duration,
      nftPrice,
      0
    );
  }

  /**
   * @dev calculates the rent price of the NFT. Imagine virtual museums that rent out
   * the NFTs of the artists for some time. Therefore, there is a potential for reputation
   * here. If the borrower has consistently good renting track-record, they will get more
   * favourable quotes
   * @param _duration number of days that the user wishes to rent out the NFT for. 1 means 1 day
   * @param _nft the address of the NFT that the user wishes to rent out
   * @return the total collateral + fee the borrower has to put up
   **/
  function calculateCollateral(
    uint256 _duration,
    address _nft,
    uint256 _tokenId
  ) public view returns (uint256) {
    // ! TODO: need to ensure that this nftPrice is relevant, and is not old
    // can we invoke chainlink price update here before computing the rentPrice?
    // collateral = _nft_price * ((collateralDailyFee) ** _duration)
    // collateral (with our service fee) = rentPrice * ourFee
    // ! this must always be populated, otherwise an error will be thrown
    uint256 collateral = assets[_nft][_tokenId].nftPrice;

    // * interest compounding
    for (uint256 i = 0; i < _duration; i++) {
      collateral = (collateral).add(
        collateral.mul(collateralDailyFee).div(10000)
      );
    }

    // this though returns price in ETH
    // we need an ability to convert it into whatever
    return collateral;
  }

  // to rent the contract:
  // 1. the borrower must have paid the indicated price (need a function to calculate this price)
  // validations:
  // 1. the borrower can't be borrowing the borrowed nft
  // (this check also ensures that the borrower is not the
  // owner & that the borrower isn't borrowing what he already borrowed)
  function rent(
    address _owner,
    address _borrower,
    uint256 _duration,
    address _nft,
    uint256 _tokenId
  ) external payable {
    require(assets[_nft][_tokenId].duration > 0, "could not find an NFT");

    // ! we only need DAI here to begin with
    require(msg.value > 0, "you need to pay the collateral");
    uint256 collateral = calculateCollateral(_duration, _nft, _tokenId);
    // TODO: check this in other currencies
    require(msg.value >= collateral, "the collateral is not adequate");

    // deposit all of the collateral with deposit
    // 0x506B0B2CF20FAA8f38a4E2B524EE43e1f4458Cc5 - is the LendingPoolAddressesProvider
    // on Kovan
    LendingPool lendingPool = LendingPool(
      address(0x506B0B2CF20FAA8f38a4E2B524EE43e1f4458Cc5)
    );
    lendingPool.deposit(
      address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE),
      msg.value,
      0
    );

    // mark the last ETHBalance with an update value of the total locked ETH
    // lastEthBalance = (this.balance).add(msg.value);

    // // determine how much aETH we received
    // uint256 newAETHBalance = aETH.balanceOf(address(this));
    // require(newAETHBalance > lastaETHBalance, "no new aETH");
    // uint256 diffAETHBalance = newAETHBalance.sub(lastaETHBalance);
    // lastaETHBalance = newAETHBalance;

    // and then immediately redirect to proxy
    aETH.redirectInterestStream(proxyInfo[_owner][_borrower]);
  }

  // create the proxy contract for managing interest when a borrower rents it out
  function createProxy(address _owner, address _borrower) internal {
    bytes memory _payload = abi.encodeWithSignature(
      "initialize(address)",
      _owner
    );
    // Deploy proxy
    // for testing the address of the proxy contract which will
    // be used to redirect interest will come here
    address _intermediate = deployMinimal(oracle, _payload);
    // user address is just recorded for tracking the proxy for the particular pair
    // TODO: need to test this for same owner but different user
    proxyInfo[_owner][_borrower] = _intermediate;
  }

  // check whether the proxy contract exists or not for a owner-borrower pair
  function getProxy(address _owner, address _borrower)
    internal
    view
    returns (address)
  {
    return proxyInfo[_owner][_borrower];
  }

  // ! can this actually be public? Wouldn't that mean that anyone can set the nftPrice with a correct requestId?
  /**
   * Receive the price response in the form of uint256
   */
  function fulfill(bytes32 _requestId, uint256 _price)
    public
    recordChainlinkFulfillment(_requestId)
  {
    nftPrice = _price;
  }
}
