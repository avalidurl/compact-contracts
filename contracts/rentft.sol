pragma solidity ^0.6.0;

import "@chainlink/contracts/src/v0.6/ChainlinkClient.sol";
import "./utils/SafeMath.sol";
import "./utils/ProxyFactory.sol";
import "./utils/OwnableUpgradeSafe.sol";
import "./utils/ContextUpgradeSafe.sol";
import "./utils/Initializable.sol";
import "./utils/Helper.sol";

interface AToken {
    /**
     * @dev redirects the interest generated to a target address.
     * when the interest is redirected, the user's balance is added to
     * the recepient's redirected balance.
     * @param _to the address to which the interest will be redirected
     **/
    function redirectInterestStream(address _to) external;

    /**
     * @dev calculates the balance of the user, which is the
     * principal balance + interest generated by the principal balance +
     * interest generated by the redirected balance
     * @param _user the user for which the balance is being calculated
     * @return the total balance of the user
     **/
    function balanceOf(address _user) external view returns (uint256);
}

// Aave Lending Pool Interface
interface LendingPool {
    function deposit(
        address _reserve,
        uint256 _amount,
        uint16 _referralCode
    ) external;
}

contract InterestCalculatorProxy is Helper, Initializable, OwnableUpgradeSafe {
    event Initialized(address indexed thisAddress);

    // proxy admin would be thw owner to prevent in fraud cases where user doesn't return the nft back
    function initialize(address _owner) public initializer {
        OwnableUpgradeSafe.__Ownable_init();
        OwnableUpgradeSafe.transferOwnership(_owner);
        emit Initialized(address(this));
    }

    function claimInterest() external view returns (uint256) {
        // All calculations to be done in the parent contract
        return AToken(getADAI()).balanceOf(address(this));
    }
}

contract Rentft is ProxyFactory, ChainlinkClient, InterestCalculatorProxy {
    using SafeMath for uint256;

    uint256 nftPrice;

    struct Asset {
        address owner;
        address borrower;
        uint256 duration;
        uint256 price;
        uint256 rent;
    }

    // proxy details
    // owner => borrower => proxy
    mapping(address => mapping(address => address)) public proxyInfo;

    // nft address => token id => asset info struct
    mapping(address => mapping(uint256 => Asset)) public assets;

    address private oracle;
    bytes32 private jobId;
    uint256 private fee;

    /**
     * Network: Kovan
     * Oracle: Chainlink - 0x2f90A6D021db21e1B2A077c5a37B3C7E75D15b7e
     * Job ID: Chainlink - 29fa9aa13bf1468788b7cc4a500a45b8
     * Link: 0xa36085F69e2889c224210F603D836748e7dC0088
     * Fee: 0.1 LINK
     */
    constructor() public {
        setPublicChainlinkToken();
        oracle = 0x2f90A6D021db21e1B2A077c5a37B3C7E75D15b7e;
        jobId = "29fa9aa13bf1468788b7cc4a500a45b8";
        fee = 0.1 * 10**18; // 0.1 LINK
    }

    // function to list the nft on the platform
    // url will be the nft address
    function addProduct(
        address nftAddress,
        uint256 nftId,
        uint256 duration,
        string calldata _url
    ) external {
        require(nftAddress != address(0), "Invalid NFT Address");
        Chainlink.Request memory request = buildChainlinkRequest(
            jobId,
            address(this),
            this.fulfill.selector
        );

        // Set the URL to perform the GET request on
        request.add("get", _url);

        // Set the path to find the desired data in the API response, where the response format is:
        request.add("path", "last_sale.payment_token.usd_price");

        // Multiply the result by 100 to remove decimals
        request.addInt("times", 1000000000000000000);

        // Sends the request
        sendChainlinkRequestTo(oracle, request, fee);

        // need to verify whether the nftPrice will have the latest value
        assets[nftAddress][nftId] = Asset(
            msg.sender,
            address(0),
            duration,
            nftPrice,
            0
        );
    }

    // create the proxy contract for managing interest when a borrower rents it out
    function createProxy(address _owner, address _borrower) internal {
        bytes memory _payload = abi.encodeWithSignature(
            "initialize(address)",
            _owner
        );
        // Deploy proxy
        // for testing the the address of the proxy contract whoch will be used to redirect interest will come here
        address _intermediate = deployMinimal(oracle, _payload);
        // user address is just recorded for tracking the proxy for the particular pair
        // TODO: need to test this for same owner but different user
        proxyInfo[_owner][_borrower] = _intermediate;
    }

    // check whether the proxy contract exists or not for a owner-borrower pair
    function getProxy(address _owner, address _borrower)
        internal
        view
        returns (address)
    {
        return proxyInfo[_owner][_borrower];
    }

    // ! can this actually be public? Wouldn't that mean that anyone can set the nftPrice with a correct requestId?
    /**
     * Receive the price response in the form of uint256
     */
    function fulfill(bytes32 _requestId, uint256 _price)
        public
        recordChainlinkFulfillment(_requestId)
    {
        nftPrice = _price;
    }
}
