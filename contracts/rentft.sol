pragma solidity ^0.6.0;

import "@chainlink/contracts/src/v0.6/ChainlinkClient.sol";
import "./utils/SafeMath.sol";
import "./utils/ProxyFactory.sol";
import "./utils/OwnableUpgradeSafe.sol";
import "./utils/ContextUpgradeSafe.sol";
import "./utils/Initializable.sol";
import "./utils/Helper.sol";

interface AToken {
    /**
     * @dev redirects the interest generated to a target address.
     * when the interest is redirected, the user's balance is added to
     * the recepient's redirected balance.
     * @param _to the address to which the interest will be redirected
     **/
    function redirectInterestStream(address _to) external;

    /**
     * @dev calculates the balance of the user, which is the
     * principal balance + interest generated by the principal balance +
     * interest generated by the redirected balance
     * @param _user the user for which the balance is being calculated
     * @return the total balance of the user
     **/
    function balanceOf(address _user) external view returns (uint256);
}

// Aave Lending Pool Interface
interface LendingPool {
    function deposit(
        address _reserve,
        uint256 _amount,
        uint16 _referralCode
    ) external;
}

contract InterestCalculatorProxy is Helper, Initializable, OwnableUpgradeSafe {
    event Initialized(address indexed thisAddress);

    // proxy admin would be the owner to prevent in fraud cases where the borrower
    // doesn't return the nft back
    function initialize(address _owner) public initializer {
        OwnableUpgradeSafe.__Ownable_init();
        OwnableUpgradeSafe.transferOwnership(_owner);
        emit Initialized(address(this));
    }

    function claimInterest() external view returns (uint256) {
        // All calculations to be done in the parent contract
        return AToken(getADAI()).balanceOf(address(this));
    }
}

contract Rentft is ProxyFactory, ChainlinkClient, InterestCalculatorProxy {
    using SafeMath for uint256;

    struct Asset {
        address owner;
        address borrower;
        uint256 duration;
        uint256 price;
        uint256 rent;
        bool active; // used to check if there is an entry in assets mapping
    }

    // proxy details
    // owner => borrower => proxy
    mapping(address => mapping(address => address)) public proxyInfo;

    // nft address => token id => asset info struct
    mapping(address => mapping(uint256 => Asset)) public assets;

    // nft address => nft price (some token Ids may be inactive
    // when we need to compute the price, loops are expensive to
    // find an id that is active, it is easier to store the prices separately)
    // ! TODO: most likely we need to somehow merge the above assets mapping and
    // this one
    // ! TODO: also need a mechanism to ensure taht this price is always relevant
    // and is not from a year ago
    mapping(address => uint256) public nftPrices;

    uint256 nftPrice; // TODO: does this makr it public? is this a conventional way of doing it? I have seen nftPrice being set below. Seems a bit strange
    address private oracle;
    bytes32 private jobId;
    uint256 private chainlinkFee; // what is this?
    uint256 private collateralDailyFee = 100; // this fee is added on top of the collateral for each hold day of the NFT. This is used to cancel out any potential swings in the price of the NFT
    // denoted in bps (basis points). 1% is 100 bps. 0.1% is 10 bps and equivalently 0.01% is 1 bps.
    uint256 private ourFee = 500; // this is how much we are earning on each rent transaction
    // we charge 5% on top of the final rent price for our services

    /**
     * Network: Kovan
     * Oracle: Chainlink - 0x2f90A6D021db21e1B2A077c5a37B3C7E75D15b7e
     * Job ID: Chainlink - 29fa9aa13bf1468788b7cc4a500a45b8
     * Link: 0xa36085F69e2889c224210F603D836748e7dC0088
     * Fee: 0.1 LINK
     */
    constructor() public {
        setPublicChainlinkToken();
        oracle = 0x2f90A6D021db21e1B2A077c5a37B3C7E75D15b7e;
        jobId = "29fa9aa13bf1468788b7cc4a500a45b8";
        chainlinkFee = 0.1 * 10**18; // 0.1 LINK
    }

    // function to list the nft on the platform
    // url will be the nft address
    function addProduct(
        address nftAddress,
        uint256 nftId,
        uint256 duration,
        string calldata _url
    ) external {
        require(nftAddress != address(0), "Invalid NFT Address");
        Chainlink.Request memory request = buildChainlinkRequest(
            jobId,
            address(this),
            this.fulfill.selector
        );

        // Set the URL to perform the GET request on
        request.add("get", _url);

        // Set the path to find the desired data in the API response, where the response format is:
        request.add("path", "last_sale.payment_token.usd_price");

        // Multiply the result by 100 to remove decimals
        request.addInt("times", 1000000000000000000);

        // Sends the request
        sendChainlinkRequestTo(oracle, request, chainlinkFee);

        // need to verify whether the nftPrice will have the latest value
        assets[nftAddress][nftId] = Asset(
            msg.sender,
            address(0),
            duration,
            nftPrice,
            0,
            true, // ! says that there is an entry in assets
        );

        assets[nftAddress] = nftPrice;
    }

    /**
     * @dev calculates the rent price of the NFT. Imagine virtual museums that rent out
     * the NFTs of the artists for some time. Therefore, there is a potential for reputation
     * here. If the borrower has consistently good renting track-record, they will get more
     * favourable quotes
     * @param _duration number of days that the user wishes to rent out the NFT for. 1 means 1 day
     * @param _nft the address of the NFT that the user wishes to rent out
     * @return the total collateral + fee the borrower has to put up
     **/
    function calculateRentPrice(uint256 _duration, address _nft) public returns(uint256) {
        // ! TODO: need to ensure that this nftPrice is relevant, and is not old
        // can we invoke chainlink price update here before computing the rentPrice?

        // rentPrice = _nft_price * ((collateralDailyFee) ** _duration)
        // rentPrice (with our service fee) = rentPrice * ourFee
        uint256 principal = assets[nftAddress];

        // * interest compounding
        for (i=0; i<_duration; i++) {
            principal = (principal).add(principal.mul(collateralDailyFee.div(10000)));
        }
        uint256 rentPrice = principal.add(principal.mul(ourFee.div(10000)));

        return rentPrice;
    }

    // to rent the contract:
    // 1. the borrower must have paid the indicated price (need a function to calculate this price)
    // validations:
    // 1. the borrower can't be borrowing the borrowed nft
    // (this check also ensures that the borrower is not the
    // owner & that the borrower isn't borrowing what he already borrowed)
    function rent(
        address _owner,
        address _borrower,
        uint256 _duration,
        address _nft,
        uint256 _tokenId,
    ) external {
        require(
            assets[_nft][_tokenId].active == false,
            "someone already rented out this NFT"
        );

        uint256 rentPrice = calculateRentPrice(_duration, _nft);
        // TODO: needs to check the value in different ERC20 currencies?
        require(msg.value >= rentPrice, "the price is not adequate");

        // take the portion for ourselves (5%)
        // our portion goes into Aave too
    }

    // create the proxy contract for managing interest when a borrower rents it out
    function createProxy(address _owner, address _borrower) internal {
        bytes memory _payload = abi.encodeWithSignature(
            "initialize(address)",
            _owner
        );
        // Deploy proxy
        // for testing the the address of the proxy contract whoch will be used to redirect interest will come here
        address _intermediate = deployMinimal(oracle, _payload);
        // user address is just recorded for tracking the proxy for the particular pair
        // TODO: need to test this for same owner but different user
        proxyInfo[_owner][_borrower] = _intermediate;
    }

    // check whether the proxy contract exists or not for a owner-borrower pair
    function getProxy(address _owner, address _borrower)
        internal
        view
        returns (address)
    {
        return proxyInfo[_owner][_borrower];
    }

    // ! can this actually be public? Wouldn't that mean that anyone can set the nftPrice with a correct requestId?
    /**
     * Receive the price response in the form of uint256
     */
    function fulfill(bytes32 _requestId, uint256 _price)
        public
        recordChainlinkFulfillment(_requestId)
    {
        nftPrice = _price;
    }
}
