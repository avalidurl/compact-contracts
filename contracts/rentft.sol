// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import "@chainlink/contracts/src/v0.6/ChainlinkClient.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "./utils/ProxyFactory.sol";
import "./utils/OwnableUpgradeSafe.sol";
import "./utils/ContextUpgradeSafe.sol";
import "./utils/Initializable.sol";
import "./utils/Helper.sol";
import "./interfaces/ILendingPoolAddressProvider.sol";
import "./interfaces/ILendingPoolCore.sol";

interface AToken {
  /**
   * @dev redirects the interest generated to a target address.
   * when the interest is redirected, the user's balance is added to
   * the recepient's redirected balance.
   * @param _to the address to which the interest will be redirected
   **/
  function redirectInterestStream(address _to) external;

  /**
   * @dev calculates the balance of the user, which is the
   * principal balance + interest generated by the principal balance +
   * interest generated by the redirected balance
   * @param _user the user for which the balance is being calculated
   * @return the total balance of the user
   **/
  function balanceOf(address _user) external view returns (uint256);
}

// Aave Lending Pool Interface
interface LendingPool {
  function deposit(
    address _reserve,
    uint256 _amount,
    uint16 _referralCode
  ) external;
}

contract InterestCalculatorProxy is Helper, Initializable, OwnableUpgradeSafe {
  event Initialized(address indexed thisAddress);

  // proxy admin would be the owner to prevent in fraud cases where the borrower
  // doesn't return the nft back
  function initialize(address _owner) public initializer {
    OwnableUpgradeSafe.__Ownable_init();
    OwnableUpgradeSafe.transferOwnership(_owner);
    emit Initialized(address(this));
  }

  function claimInterest() external view returns (uint256) {
    // All calculations to be done in the parent contract
    return AToken(getADAI()).balanceOf(address(this));
  }
}

contract Rentft is
  ProxyFactory,
  ChainlinkClient,
  InterestCalculatorProxy,
  ReentrancyGuard
{
  // using SafeMath for uint256;
  using SafeERC20 for ERC20;

  struct Asset {
    address owner;
    address borrower;
    uint256 duration;
    uint256 nftPrice;
    uint256 collateral;
  }

  // proxy details
  // owner => borrower => proxy
  mapping(address => mapping(address => address)) public proxyInfo;

  // nft address => token id => asset info struct
  mapping(address => mapping(uint256 => Asset)) public assets;

  uint256 public ourInterestProxy;
  uint256 private nftPrice;
  address private oracle;
  bytes32 private jobId;
  uint256 private chainlinkFee;
  // this fee is added on top of the collateral for each hold day of the NFT.
  // This is used to cancel out any potential swings in the price of the NFT
  // denoted in bps (basis points). 1% is 100 bps. 0.1% is 10 bps and
  // equivalently 0.01% is 1 bps. The mechanism for computing the rent will
  // change in the future, to be more efficient and meaningful
  uint256 public collateralDailyFee = 100;
  address public ethAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

  ILendingPoolAddressesProvider public addressesProvider;
  ILendingPoolCore public core;

  /**
   * Network: Kovan
   * Oracle: Chainlink - 0x2f90A6D021db21e1B2A077c5a37B3C7E75D15b7e
   * Job ID: Chainlink - 29fa9aa13bf1468788b7cc4a500a45b8
   * Link: 0xa36085F69e2889c224210F603D836748e7dC0088
   * Fee: 0.1 LINK
   */
  // provide aave address provider for the network you are working on
  // get all aave related addresses through addressesProvider state var
  // get all aToken reserve addresses through the core state var
  constructor(address _aaveAdressesProvider) public {
    setPublicChainlinkToken();
    oracle = 0x2f90A6D021db21e1B2A077c5a37B3C7E75D15b7e;
    jobId = "29fa9aa13bf1468788b7cc4a500a45b8";
    chainlinkFee = 0.1 * 10**18; // 0.1 LINK

    addressesProvider = ILendingPoolAddressesProvider(_aaveAdressesProvider);
    core = ILendingPoolCore(addressesProvider.getLendingPoolCore());
  }

  // function to list the nft on the platform
  // url will be the nft address
  function addProduct(
    address nftAddress,
    uint256 nftId,
    uint256 duration,
    string calldata _url
  ) external {
    require(nftAddress != address(0), "Invalid NFT Address");
    Chainlink.Request memory request = buildChainlinkRequest(
      jobId,
      address(this),
      this.fulfill.selector
    );

    // Set the URL to perform the GET request on
    request.add("get", _url);

    // Set the path to find the desired data in the API response, where the response format is:
    request.add("path", "last_sale.payment_token.usd_price");

    // Multiply the result by 100 to remove decimals
    request.addInt("times", 1000000000000000000);

    // Sends the request
    sendChainlinkRequestTo(oracle, request, chainlinkFee);

    // need to verify whether the nftPrice will have the latest value
    assets[nftAddress][nftId] = Asset(
      msg.sender,
      address(0),
      duration,
      nftPrice,
      0
    );
  }

  /**
   * @dev calculates the rent price of the NFT. Imagine virtual museums that rent out
   * the NFTs of the artists for some time. Therefore, there is a potential for reputation
   * here. If the borrower has consistently good renting track-record, they will get more
   * favourable quotes
   * @param _duration number of days that the user wishes to rent out the NFT for. 1 means 1 day
   * @param _nft the address of the NFT that the user wishes to rent out
   * @return the total collateral + fee the borrower has to put up
   **/
  function calculateCollateral(
    uint256 _duration,
    address _nft,
    uint256 _tokenId
  ) public view returns (uint256) {
    // ! TODO: need to ensure that this nftPrice is relevant, and is not old
    // can we invoke chainlink price update here before computing the rentPrice?
    // collateral = _nft_price * ((collateralDailyFee) ** _duration)
    // collateral (with our service fee) = rentPrice * ourFee
    // ! this must always be populated, otherwise an error will be thrown
    uint256 collateral = assets[_nft][_tokenId].nftPrice;

    // * interest compounding
    for (uint256 i = 0; i < _duration; i++) {
      collateral = (collateral).add(collateral.mul(collateralDailyFee).div(10000));
    }

    // this though returns price in ETH
    // we need an ability to convert it into whatever
    return collateral;
  }

  /**
   * @dev transfers an amount from a user to the destination proxy address where it
   * subsequently gets deposited into Aave
   * @param _reserve the address of the reserve where the amount is being transferred
   * @param _user the address of the user from where the transfer is happening
   * @param _amount the amount being transferred
   **/
  function transferToProxy(
    address _reserve,
    address payable _user,
    uint256 _amount,
    address _proxy
  ) private {
    if (_reserve != ethAddress) {
      require(
        msg.value == 0,
        "User is sending ETH along with the ERC20 transfer."
      );
      // ! our contract should be approved to move his ERC20 funds
      ERC20(_reserve).safeTransferFrom(address(this), _proxy, _amount);
    } else {
      // * this is used for ETH. we don't need it for now
      require(
        msg.value >= _amount,
        "The amount and the value sent to deposit do not match"
      );

      if (msg.value > _amount) {
        //send back excess ETH
        uint256 excessAmount = msg.value.sub(_amount);
        //solium-disable-next-line
        (bool result, ) = _user.call{value: excessAmount, gas: 50000}("");
        require(result, "Transfer of ETH failed");
      }
    }
  }

  // to rent the contract:
  // 1. the borrower must have paid the indicated collateral
  // validations:
  // 1. the borrower can't be borrowing the borrowed nft
  // (this check also ensures that the borrower is not the
  // owner & that the borrower isn't borrowing what he already borrowed)
  function rent(
    address _owner,
    address _borrower,
    uint256 _duration,
    address _nft,
    uint256 _tokenId,
    uint256 _collateralOffered,
    address payable _currencyCollateralPaidIn
  ) external payable nonReentrant returns (bool) {
    require(assets[_nft][_tokenId].duration > 0, "could not find an NFT");

    // ! we only need DAI here to begin with
    // require(msg.value > 0, "you need to pay the collateral");
    uint256 collateral = calculateCollateral(_duration, _nft, _tokenId);
    require(collateral >= _collateralOffered, "the collateral is too low");

    // ? Is this going to fail? proxy isn't payable
    // ! will fail if the msg.sender hasn't approved us as the spender of their ERC20 tokens
    transferToProxy(
      _currencyCollateralPaidIn,
      msg.sender,
      _collateralOffered,
      proxyInfo[_owner][_borrower]
    );

    return true;
  }

  // create the proxy contract for managing interest when a borrower rents it out
  function createProxy(address _owner, address _borrower) internal {
    bytes memory _payload = abi.encodeWithSignature(
      "initialize(address)",
      _owner
    );
    // Deploy proxy
    // for testing the address of the proxy contract which will
    // be used to redirect interest will come here
    address _intermediate = deployMinimal(oracle, _payload);
    // user address is just recorded for tracking the proxy for the particular pair
    // TODO: need to test this for same owner but different user
    proxyInfo[_owner][_borrower] = _intermediate;
  }

  // check whether the proxy contract exists or not for a owner-borrower pair
  function getProxy(address _owner, address _borrower)
    internal
    view
    returns (address)
  {
    return proxyInfo[_owner][_borrower];
  }

  // ! can this actually be public? Wouldn't that mean that anyone can set the nftPrice with a correct requestId?
  /**
   * Receive the price response in the form of uint256
   */
  function fulfill(bytes32 _requestId, uint256 _price)
    public
    recordChainlinkFulfillment(_requestId)
  {
    nftPrice = _price;
  }
}
